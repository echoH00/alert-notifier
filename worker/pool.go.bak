package worker

import (
	"github.com/echoH00/alert-notifier/alertstore"
	"github.com/echoH00/alert-notifier/config"
	"log"
	"sync"
	"time"
)

var (
	jobQueue     = make(chan alertstore.AlertJob, config.JobQueueSize)
	deadLetters  = make(chan alertstore.AlertJob, config.DeadLetterSize)
	lastActivity = make(map[int]time.Time)
	workerCount  = 0
	mu           sync.Mutex
)

func InitPool() {
	for i := 1; i <= config.MinWorkers; i++ {
		startWorker(i)
	}
}

func EnqueueJob(job alertstore.AlertJob) {
	select {
	case jobQueue <- job:
		log.Printf("Job enqueued: %v", job.Alert.Labels)
		scaleUpWorker()
	default:
		log.Println("Queue full, dropping job")
	}
}

func scaleUpWorker() {
	mu.Lock()
	defer mu.Unlock()
	if workerCount < config.MaxWorkers {
		log.Printf("[Worker] added")
		startWorker(workerCount + 1)
	}
}

func JobQueue() chan alertstore.AlertJob {
	return jobQueue
}

func DeadLetterQueue() chan alertstore.AlertJob {
	return deadLetters
}

func TrackActivity(id int) {
	log.Printf("In trackActivity")
	mu.Lock()
	lastActivity[id] = time.Now()
	log.Printf("value: %v", lastActivity[id])
	log.Printf("等待解锁")
	mu.Unlock()
	log.Printf("In trackActivity Done")
}

func CanExitWorker(id int) bool {
	mu.Lock()
	defer mu.Unlock()
	if workerCount > config.MinWorkers &&
		time.Since(lastActivity[id]) > config.IdleTimeout {
		delete(lastActivity, id)
		workerCount--
		return true
	}
	return false
}

func IncrementWorker() int {
	mu.Lock()
	defer mu.Unlock()
	workerCount++
	return workerCount
}

